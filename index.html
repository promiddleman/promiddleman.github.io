<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chess Game</title>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            background-color: #f0f0f0;
            color: #333;
        }
        
        h1 {
            margin-bottom: 20px;
            color: #2c3e50;
        }
        
        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-bottom: 20px;
        }
        
        .board {
            display: grid;
            grid-template-columns: repeat(8, 60px);
            grid-template-rows: repeat(8, 60px);
            border: 10px solid #654321;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.3);
        }
        
        .square {
            width: 60px;
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 40px;
            cursor: pointer;
            user-select: none;
        }
        
        .light {
            background-color: #f0d9b5;
        }
        
        .dark {
            background-color: #b58863;
        }
        
        .selected {
            background-color: rgba(173, 216, 230, 0.7);
        }
        
        .valid-move {
            position: relative;
        }
        
        .valid-move::before {
            content: "";
            position: absolute;
            width: 20px;
            height: 20px;
            background-color: rgba(0, 128, 0, 0.4);
            border-radius: 50%;
            z-index: 1;
        }
        
        .turn-indicator {
            margin-top: 20px;
            font-size: 1.2rem;
            font-weight: bold;
            padding: 10px;
            border-radius: 5px;
            background-color: #eee;
        }
        
        .controls {
            margin-top: 20px;
            display: flex;
            gap: 10px;
        }
        
        button {
            padding: 10px 15px;
            font-size: 1rem;
            background-color: #2c3e50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        
        button:hover {
            background-color: #1a2530;
        }
        
        .piece-promotion {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: white;
            padding: 20px;
            border-radius: 5px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            display: none;
            flex-direction: column;
            align-items: center;
            z-index: 10;
        }
        
        .promotion-options {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }
        
        .promotion-piece {
            width: 60px;
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 40px;
            background-color: #f0d9b5;
            cursor: pointer;
            border: 1px solid #999;
        }
        
        .footer {
            margin-top: 30px;
            text-align: center;
            font-size: 0.9rem;
            color: #777;
        }
    </style>
</head>
<body>
    <h1>Chess Game</h1>
    
    <div class="game-container">
        <div class="board" id="chessboard"></div>
        <div class="turn-indicator" id="turnIndicator">White's Turn</div>
        
        <div class="controls">
            <button id="resetBtn">New Game</button>
            <button id="undoBtn">Undo Move</button>
        </div>
    </div>
    
    <div class="piece-promotion" id="promotionDialog">
        <h3>Choose a piece for promotion</h3>
        <div class="promotion-options" id="promotionOptions"></div>
    </div>
    
    <div class="footer">
        <p>Created with ❤️ | <a href="https://github.com/yourusername" target="_blank">GitHub</a></p>
    </div>
    
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const board = document.getElementById('chessboard');
            const turnIndicator = document.getElementById('turnIndicator');
            const resetBtn = document.getElementById('resetBtn');
            const undoBtn = document.getElementById('undoBtn');
            const promotionDialog = document.getElementById('promotionDialog');
            const promotionOptions = document.getElementById('promotionOptions');
            
            let selectedSquare = null;
            let currentTurn = 'white';
            let moveHistory = [];
            let pendingPromotion = null;
            
            // Chess piece unicode characters
            const pieces = {
                'white': {
                    'pawn': '♙',
                    'rook': '♖',
                    'knight': '♘',
                    'bishop': '♗',
                    'queen': '♕',
                    'king': '♔'
                },
                'black': {
                    'pawn': '♟',
                    'rook': '♜',
                    'knight': '♞',
                    'bishop': '♝',
                    'queen': '♛',
                    'king': '♚'
                }
            };
            
            // Initial board setup
            const initialBoard = [
                ['black-rook', 'black-knight', 'black-bishop', 'black-queen', 'black-king', 'black-bishop', 'black-knight', 'black-rook'],
                ['black-pawn', 'black-pawn', 'black-pawn', 'black-pawn', 'black-pawn', 'black-pawn', 'black-pawn', 'black-pawn'],
                ['', '', '', '', '', '', '', ''],
                ['', '', '', '', '', '', '', ''],
                ['', '', '', '', '', '', '', ''],
                ['', '', '', '', '', '', '', ''],
                ['white-pawn', 'white-pawn', 'white-pawn', 'white-pawn', 'white-pawn', 'white-pawn', 'white-pawn', 'white-pawn'],
                ['white-rook', 'white-knight', 'white-bishop', 'white-queen', 'white-king', 'white-bishop', 'white-knight', 'white-rook']
            ];
            
            let gameState = JSON.parse(JSON.stringify(initialBoard));
            
            // Create the chessboard
            function createBoard() {
                board.innerHTML = '';
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const square = document.createElement('div');
                        square.className = `square ${(row + col) % 2 === 0 ? 'light' : 'dark'}`;
                        square.dataset.row = row;
                        square.dataset.col = col;
                        
                        const piece = gameState[row][col];
                        if (piece) {
                            const [color, type] = piece.split('-');
                            square.textContent = pieces[color][type];
                        }
                        
                        square.addEventListener('click', () => handleSquareClick(row, col));
                        board.appendChild(square);
                    }
                }
            }
            
            // Handle square clicks
            function handleSquareClick(row, col) {
                const clickedPiece = gameState[row][col];
                
                // If there's a pending promotion, don't allow other moves
                if (pendingPromotion) return;
                
                // If no square is selected yet
                if (!selectedSquare) {
                    // Check if clicked on own piece
                    if (clickedPiece && clickedPiece.startsWith(currentTurn)) {
                        selectedSquare = { row, col };
                        highlightSquare(row, col);
                        showValidMoves(row, col);
                    }
                } else {
                    // If clicking on the same square, deselect it
                    if (selectedSquare.row === row && selectedSquare.col === col) {
                        clearHighlights();
                        selectedSquare = null;
                        return;
                    }
                    
                    // If clicking on another own piece, select that instead
                    if (clickedPiece && clickedPiece.startsWith(currentTurn)) {
                        clearHighlights();
                        selectedSquare = { row, col };
                        highlightSquare(row, col);
                        showValidMoves(row, col);
                        return;
                    }
                    
                    // Otherwise, try to move the selected piece
                    const selectedPiece = gameState[selectedSquare.row][selectedSquare.col];
                    const isValidMove = isValidMoveForPiece(selectedPiece, selectedSquare.row, selectedSquare.col, row, col);
                    
                    if (isValidMove) {
                        // Save the move to history before making it
                        moveHistory.push({
                            from: { row: selectedSquare.row, col: selectedSquare.col },
                            to: { row, col },
                            piece: selectedPiece,
                            captured: gameState[row][col]
                        });
                        
                        // Handle pawn promotion
                        if (selectedPiece.endsWith('pawn') && (row === 0 || row === 7)) {
                            pendingPromotion = { row, col, fromRow: selectedSquare.row, fromCol: selectedSquare.col };
                            showPromotionDialog(row, col);
                        } else {
                            // Make the move
                            gameState[row][col] = selectedPiece;
                            gameState[selectedSquare.row][selectedSquare.col] = '';
                            
                            // Switch turn
                            currentTurn = currentTurn === 'white' ? 'black' : 'white';
                            turnIndicator.textContent = `${currentTurn.charAt(0).toUpperCase() + currentTurn.slice(1)}'s Turn`;
                        }
                        
                        // Update the board
                        clearHighlights();
                        createBoard();
                        selectedSquare = null;
                    }
                }
            }
            
            // Highlight the selected square
            function highlightSquare(row, col) {
                const square = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
                square.classList.add('selected');
            }
            
            // Clear all highlights
            function clearHighlights() {
                const squares = document.querySelectorAll('.square');
                squares.forEach(square => {
                    square.classList.remove('selected');
                    square.classList.remove('valid-move');
                });
            }
            
            // Show promotion dialog
            function showPromotionDialog(row, col) {
                promotionOptions.innerHTML = '';
                const color = currentTurn;
                
                const promotionPieces = ['queen', 'rook', 'bishop', 'knight'];
                promotionPieces.forEach(piece => {
                    const option = document.createElement('div');
                    option.className = 'promotion-piece';
                    option.textContent = pieces[color][piece];
                    option.addEventListener('click', () => {
                        promotePawn(piece);
                    });
                    promotionOptions.appendChild(option);
                });
                
                promotionDialog.style.display = 'flex';
            }
            
            // Promote pawn to selected piece
            function promotePawn(pieceType) {
                if (!pendingPromotion) return;
                
                const { row, col, fromRow, fromCol } = pendingPromotion;
                
                // Update the last move in history to include promotion info
                moveHistory[moveHistory.length - 1].promotion = pieceType;
                
                // Make the move with promotion
                gameState[row][col] = `${currentTurn}-${pieceType}`;
                gameState[fromRow][fromCol] = '';
                
                // Switch turn
                currentTurn = currentTurn === 'white' ? 'black' : 'white';
                turnIndicator.textContent = `${currentTurn.charAt(0).toUpperCase() + currentTurn.slice(1)}'s Turn`;
                
                // Update the board
                createBoard();
                pendingPromotion = null;
                promotionDialog.style.display = 'none';
            }
            
            // Show valid moves for the selected piece
            function showValidMoves(row, col) {
                const piece = gameState[row][col];
                if (!piece) return;
                
                for (let r = 0; r < 8; r++) {
                    for (let c = 0; c < 8; c++) {
                        if (isValidMoveForPiece(piece, row, col, r, c)) {
                            const square = document.querySelector(`[data-row="${r}"][data-col="${c}"]`);
                            square.classList.add('valid-move');
                        }
                    }
                }
            }
            
            // Check if a move is valid for a specific piece
            function isValidMoveForPiece(piece, fromRow, fromCol, toRow, toCol) {
                if (!piece) return false;
                
                const [color, type] = piece.split('-');
                const targetPiece = gameState[toRow][toCol];
                
                // Can't capture own pieces
                if (targetPiece && targetPiece.startsWith(color)) return false;
                
                // Simple move validation for each piece type
                switch (type) {
                    case 'pawn':
                        return isValidPawnMove(color, fromRow, fromCol, toRow, toCol);
                    case 'rook':
                        return isValidRookMove(fromRow, fromCol, toRow, toCol);
                    case 'knight':
                        return isValidKnightMove(fromRow, fromCol, toRow, toCol);
                    case 'bishop':
                        return isValidBishopMove(fromRow, fromCol, toRow, toCol);
                    case 'queen':
                        return isValidQueenMove(fromRow, fromCol, toRow, toCol);
                    case 'king':
                        return isValidKingMove(fromRow, fromCol, toRow, toCol);
                    default:
                        return false;
                }
            }
            
            // Pawn move validation
            function isValidPawnMove(color, fromRow, fromCol, toRow, toCol) {
                const direction = color === 'white' ? -1 : 1;
                const startRow = color === 'white' ? 6 : 1;
                
                // Moving one square forward
                if (fromCol === toCol && toRow === fromRow + direction && !gameState[toRow][toCol]) {
                    return true;
                }
                
                // Moving two squares forward from starting position
                if (fromCol === toCol && fromRow === startRow && toRow === fromRow + 2 * direction && 
                    !gameState[fromRow + direction][fromCol] && !gameState[toRow][toCol]) {
                    return true;
                }
                
                // Capturing diagonally
                if (Math.abs(fromCol - toCol) === 1 && toRow === fromRow + direction && 
                    gameState[toRow][toCol] && !gameState[toRow][toCol].startsWith(color)) {
                    return true;
                }
                
                return false;
            }
            
            // Rook move validation
            function isValidRookMove(fromRow, fromCol, toRow, toCol) {
                // Must move along ranks or files
                if (fromRow !== toRow && fromCol !== toCol) return false;
                
                // Check for pieces in the way
                if (fromRow === toRow) {
                    const start = Math.min(fromCol, toCol);
                    const end = Math.max(fromCol, toCol);
                    for (let c = start + 1; c < end; c++) {
                        if (gameState[fromRow][c]) return false;
                    }
                } else {
                    const start = Math.min(fromRow, toRow);
                    const end = Math.max(fromRow, toRow);
                    for (let r = start + 1; r < end; r++) {
                        if (gameState[r][fromCol]) return false;
                    }
                }
                
                return true;
            }
            
            // Knight move validation
            function isValidKnightMove(fromRow, fromCol, toRow, toCol) {
                const rowDiff = Math.abs(fromRow - toRow);
                const colDiff = Math.abs(fromCol - toCol);
                
                return (rowDiff === 2 && colDiff === 1) || (rowDiff === 1 && colDiff === 2);
            }
            
            // Bishop move validation
            function isValidBishopMove(fromRow, fromCol, toRow, toCol) {
                // Must move diagonally
                if (Math.abs(fromRow - toRow) !== Math.abs(fromCol - toCol)) return false;
                
                // Check for pieces in the way
                const rowStep = fromRow < toRow ? 1 : -1;
                const colStep = fromCol < toCol ? 1 : -1;
                let r = fromRow + rowStep;
                let c = fromCol + colStep;
                
                while (r !== toRow && c !== toCol) {
                    if (gameState[r][c]) return false;
                    r += rowStep;
                    c += colStep;
                }
                
                return true;
            }
            
            // Queen move validation
            function isValidQueenMove(fromRow, fromCol, toRow, toCol) {
                return isValidRookMove(fromRow, fromCol, toRow, toCol) || 
                       isValidBishopMove(fromRow, fromCol, toRow, toCol);
            }
            
            // King move validation
            function isValidKingMove(fromRow, fromCol, toRow, toCol) {
                return Math.abs(fromRow - toRow) <= 1 && Math.abs(fromCol - toCol) <= 1;
            }
            
            // Undo the last move
            function undoLastMove() {
                if (moveHistory.length === 0) return;
                
                const lastMove = moveHistory.pop();
                const { from, to, piece, captured } = lastMove;
                
                // Restore pieces
                gameState[from.row][from.col] = piece;
                gameState[to.row][to.col] = captured || '';
                
                // Switch turn back
                currentTurn = currentTurn === 'white' ? 'black' : 'white';
                turnIndicator.textContent = `${currentTurn.charAt(0).toUpperCase() + currentTurn.slice(1)}'s Turn`;
                
                // Update the board
                createBoard();
                selectedSquare = null;
                pendingPromotion = null;
                promotionDialog.style.display = 'none';
            }
            
            // Reset the game
            function resetGame() {
                gameState = JSON.parse(JSON.stringify(initialBoard));
                currentTurn = 'white';
                turnIndicator.textContent = `${currentTurn.charAt(0).toUpperCase() + currentTurn.slice(1)}'s Turn`;
                moveHistory = [];
                selectedSquare = null;
                pendingPromotion = null;
                promotionDialog.style.display = 'none';
                createBoard();
            }
            
            // Event listeners
            resetBtn.addEventListener('click', resetGame);
            undoBtn.addEventListener('click', undoLastMove);
            
            // Initialize the game
            createBoard();
        });
    </script>
</body>
</html>
